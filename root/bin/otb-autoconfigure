#!/bin/sh
# shellcheck disable=SC1090,SC1091,SC1066,SC1087,SC2086,SC2016,SC2039
# vim: set noexpandtab tabstop=4 shiftwidth=4 softtabstop=4:
#ACS_URL=192.168.100.10:8080

ACS_PATH_PATH=/tmp/acs_hash

. /lib/overthebox

_call_acs() {
	curl -s -m 10 --fail -L "$ACS_URL/device/$OTB_DEVICE_ID/$1"
}

_check_connect_acs() {
	if [ -z "$(uci changes)" ]; then
		logger "No changes, no need to check"
		return 0
	fi

	local ret
	logger "Checking connectivity"
	if ! curl -s -m 10 --fail -L "$ACS_URL/ping" > /dev/null; then
		logger "New conf is breaking network, reversing"

		logger "changes are $(uci changes)"

		parsed="$(uci changes | grep -o '[a-zA-Z]*\.' | sed 's/\.$//' | sort | uniq )"
		logger "parsed changes $parsed"

		uci changes | grep -o  '[a-zA-Z]*\.' \
		| sed 's/\.$//' | sort | uniq \
		| xargs -n 1 uci revert

		return 1
	fi
}

_check_hash() {
	local uci_path="$1"
	local conf="$2"

	escaped_path="$(printf "%s" "$uci_path" | sed 's/[.[\*^$()+?{|]/\\&/g')"

	touch "$ACS_PATH_PATH"

	rhash="$(echo "$conf" | md5sum | cut -d" " -f1)"
	lhash="$(grep "$escaped_path" "$ACS_PATH_PATH" | cut -d";" -f2)"

	if [ "$rhash" = "$lhash" ]; then
		return 1
	fi

	# Remove the hash if exists
	tmp_file="$(mktemp)"
	awk "!/$escaped_path/{print}" "$ACS_PATH_PATH" > "$tmp_file"
	mv "$tmp_file" "$ACS_PATH_PATH"

	echo "$uci_path;$rhash" >> "$ACS_PATH_PATH"
}

# Takes an input as { "key": "value" } and apply it as an uci configuration on uci_path as "set uci_path.key=value"
_set_conf_single_static() {
	local conf="$1"
	local uci_path="$2"
	local conf_type="$3"

	# Remove empty values
	conf="$(echo $conf | jq 'del(.[] | select(. == "null"))')"

	# Check hash
	if ! _check_hash "$uci_path" "$ret"; then
		return 1
	fi

	logger "Updating $uci_path"

	# Map key to value
	uci set "$uci_path="
	uci set "$uci_path=$conf_type"
	echo "$conf" | jq -r --arg ucipath "$uci_path"  'to_entries | .[] | @text "set \($ucipath).\(.key)=\"\(.value)\""' | uci -q batch

	# No need to delete rules as they are deleted if set to ""
}

# _set_conf_list sets conf as uci list
# conf: array of values eg: [ "value1", "value2" ]
# path: path of the list eg: dhcp.@dnsmasq[0].server
_set_conf_list() {
	local conf="$1"
	local uci_path="$2"

	if ! _check_hash "$uci_path" "$conf"; then
		return 1
	fi

	logger "Updating $uci_path"

	# Delete the list before adding values
	uci set "$uci_path="

	echo "$conf" | jq -r '.[]' | while read -r value; do
		echo uci add_list "$uci_path=$value"
		uci add_list "$uci_path=$value"
	done
}

_find_rule_index() {
	local rule="$1"
	local conf_id="$2"

	found=false
	i=0
	id=
	while true; do
		uci show "$rule[$i]" > /dev/null 2>&1 || break
		id="$(uci get "$rule[$i].id" 2>/dev/null || true)"
		if [ "$id" = "$conf_id" ]; then
			found=true
			break
		fi
		i=$((i+1))
	done

	if [ "$found" = false ]; then
		echo "-1"
	else
		echo "$i"
	fi
}

# _set_conf_array sets conf in an array TODO: Improve this, seems a bit too hacky
_set_conf_array() {
	local conf="$1"

	# Is of shape: firewall.@rule
	uci_path_array="$2"

	# Convert to firewall.rule
	uci_path="$(echo $uci_path_array | sed 's/\@//g')"

	# Convert to firewall rule
	uci_cmd="$(echo $uci_path | sed -n -r  's/(^[a-z]*)(\.)/\1 /p')"

	# Check hash
	if ! _check_hash "$uci_path" "$ret"; then
		return 1
	fi

	logger "Updating $uci_path"

	# Set the new rules
	echo "$conf" | jq -r -c ".[]" | while read -r sconf; do
		conf_id="$(echo "$sconf" | jq -r .id )"
		i="$(_find_rule_index "$uci_path_array" "$conf_id")"

		if [ "$i" -eq "-1" ]; then
			echo "Rule does not exist, creating"

			# Intentional word splitting
			uci add $uci_cmd > /dev/null
		fi

		# Map key to value
		echo "$sconf" | jq -r --arg index "$i" --arg ucipath "$uci_path_array"  'to_entries | .[] | @text "set \($ucipath)[\($index)].\(.key)=\"\(.value)\""' | uci -q batch
	done

	# Delete undefined rules
	i=0
	while true; do
		# We finished iterating over all rules
		uci show "$uci_path_array[$i]" > /dev/null 2>&1 || break

		# If no id is defined, it's should not be there (system rule)
		id=$(uci get "$uci_path_array[$i].id" 2> /dev/null)
		if [ -z "$id" ]; then
			uci delete "$uci_path_array[$i]"
			continue
		fi

		# Check if id is still present in remote config
		if ! echo "$ret" | jq -e -r --arg id "$id" '[.[].id] | index("\($id)")' > /dev/null; then
			uci delete "$uci_path_array[$i]"
			continue
		fi

		i=$((i+1))
	done
}

_set_conf_firewall_rules() {
	conf="$1"

	sconf="$(echo "$conf" | jq -r '[ .[] | {
		"name":      "\(.name)",
		"target":    "\(.target)",
		"src":       "\(.src)",
		"dest":      "\(.dest)",
		"dest_ip":   "\(.dest_ip)",
		"dest_port": "\(.dest_port)",
		"family":    "\(.family)",
		"icmp_type": "\(.icmp_type)",
		"limit":     "\(.limit)",
		"proto":     "\(.proto)",
		"src_ip":    "\(.src_ip)",
		"id":        "\(.id)"
	}] | del(.[][] | select(. == "null"))')"

	_set_conf_array "$sconf" "firewall.@rule"

	if [ -n "$(uci changes)" ]; then
		/etc/init.d/firewall reload
	fi
}

_set_conf_firewall_redirects() {
	conf="$1"

	sconf="$(echo "$conf" | jq -r '[ .[] | {
		"target":    "\(.target)",
		"src":       "\(.src)",
		"dest":      "\(.dest)",
		"enabled":   "\(.enabled)",
		"src_dport": "\(.src_dport)",
		"dest_port": "\(.dest_port)",
		"dest_ip":   "\(.dest_ip)",
		"proto":     "\(.proto)",
		"id":        "\(.id)"
	}] | del(.[][] | select(. == "null"))')"


	_set_conf_array "$sconf" "firewall.@redirect"

	if [ -n "$(uci changes)" ]; then
		/etc/init.d/firewall reload
	fi
}

_set_conf_dhcp_staticleases() {
	conf="$1"

	sconf="$(echo "$conf" | jq -r '[ .[] | {
		"name":     "\(.hostname)",
		"mac":      "\(.mac)",
		"ip":       "\(.ip)",
		"id":       "\(.id)"
	}] | del(.[][] | select(. == "null"))')"

	echo "setting conf to $sconf"

	_set_conf_array "$sconf" "dhcp.@host"

	if [ -n "$(uci changes)" ]; then
		/etc/init.d/dnsmasq restart
	fi
}

_set_conf_network_interface() {
	local conf="$1"

	echo "$conf" | jq -r -c ".[]" | while read -r sconf; do
		interface="$(echo "$sconf" | jq -r ".interface")"
		_set_conf_single_static "$sconf" "network.$interface" "interface"
	done

	if [ -n "$(uci changes)" ]; then
		/etc/init.d/network reload
	fi
}

_set_conf_network_routes6() {
	local conf="$1"

	echo "$conf" | jq -r -c ".[]" | while read -r sconf; do
		name="$(echo "$sconf" | jq -r ".name")"
		sconf="$(echo "$sconf" | jq -r '{
			"interface": "\(.interface)",
			"target":    "\(.target)",
			"netmask":   "\(.netmask)",
			"gateway":   "\(.gateway)",
			"metric":    "\(.metric)",
			"mtu":       "\(.mtu)",
			"table":     "\(.table)",
			"source":    "\(.source)",
			"onlink":    "\(.onlink)",
			"type":      "\(.type)",
		}')"

		_set_conf_single_static	"$sconf" "network.$name" "route6"
	done

	if [ -n "$(uci changes)" ]; then
		/etc/init.d/network reload
	fi
}

_set_conf_network_routes4() {
	local conf="$1"

	# TODO: Find a way to not use interface when setting route
	echo "$conf" | jq -r -c ".[]" | while read -r sconf; do
		name="$(echo "$sconf" | jq -r ".name")"
		sconf="$(echo "$sconf" | jq -r '{
			"interface": "\(.interface)",
			"target":    "\(.target)",
			"netmask":   "\(.netmask)",
			"gateway":   "\(.gateway)",
			"metric":    "\(.metric)",
			"mtu":       "\(.mtu)",
			"table":     "\(.table)",
			"source":    "\(.source)",
			"onlink":    "\(.onlink)",
			"type":      "\(.type)",
		}')"

		_set_conf_single_static	"$sconf" "network.$name" "route"
	done

	if [ -n "$(uci changes)" ]; then
		/etc/init.d/network reload
	fi
}

_set_conf_glorytun() {
	local conf="$1"

	echo $conf | jq -r -c ".[]" | while read -r sconf; do
		tconf="$(echo $sconf | jq -r '{
			"dev":    "\(.dev_name)",
			"server": "\(.server)",
			"port":   "\(.port)",
			"key":    "\(.key)",
			"id":     "\(.id)",
			"enable": 1
		}')"

		dev_name="$(echo $tconf | jq -r  '.dev_name')"

		_set_conf_single_static "$tconf" "glorytun.$dev_name" "mud"
	done

	if [ -n "$(uci changes)" ]; then
		/etc/init.d/glorytun reload
	fi
}

_set_conf_dhcp_config() {
	local conf="$1"

	echo "$conf" | jq -r -c ".[]" | while read -r sconf; do
		interface="$(echo $sconf | jq -r '.interface')"
		tconf="$(echo $sconf | jq -r '{
			"start":     "\(.start)",
			"limit":     "\(.end)",
			"leasetime": "\(.lease_time)",
			"force":     "1",
			"ra":        "1"
		}')"

	_set_conf_single_static "$tconf" "dhcp.$interface" "dhcp"
	done

	if [ -n "$(uci changes)" ]; then
		/etc/init.d/dnsmasq restart
	fi
}

_set_conf_dns_nameserver() {
	local conf="$1"

	sconf="$(echo "$conf" | jq -r '[.[].server]')"

	echo "setting conf list to sconf"

	_set_conf_list "$sconf" "dhcp.@dnsmasq[0].server"

	if [ -n "$(uci changes)" ]; then
		/etc/init.d/dnsmasq restart
	fi
}

_apply_remote_conf() {
	url="$1"

	# Get conf JSON
	ret="$(_call_acs "$url")" || {
		logger "cannot reach $url"
		return 1
	}

	if [ "$url" = "dhcp/configs" ]; then
		_set_conf_dhcp_config "$ret"

	elif [ "$url" = "dhcp/staticleases" ]; then
		_set_conf_dhcp_staticleases "$ret"

	elif [ "$url" = "dns/nameservers" ]; then
		_set_conf_dns_nameserver "$ret"

	elif [ "$url" = "firewall/redirects" ]; then
		_set_conf_firewall_redirects "$ret"

	elif [ "$url" = "firewall/rules" ]; then
		_set_conf_firewall_rules "$ret"

	elif [ "$url" = "glorytun/tun" ]; then
		_set_conf_glorytun "$ret"

	elif [ "$url" = "network/interfaces" ]; then
		_set_conf_network_interface "$ret"

	elif [ "$url" = "network/routes4" ]; then
		_set_conf_network_routes4 "$ret"

	elif [ "$url" = "network/routes6" ]; then
		_set_conf_network_routes6 "$ret"

	else
		echo "Missing conf type"
	fi

	_check_connect_acs "$uci_path" || return

	uci commit
}

_run() {
	otb_reload

	#if [ -z "$OTB_DEVICE_ID" ]; then
		#logger "No device ID"
		#return 1
	#fi

	# Force deviceID
	export OTB_DEVICE_ID=a5def614-0f23-4c17-a72b-f8d7704ce070
	ACS_URL=192.168.100.10:8080

	logger "Device ID is $OTB_DEVICE_ID"

	_apply_remote_conf  "dhcp/configs"
	_apply_remote_conf  "dhcp/staticleases"
	_apply_remote_conf  "dns/nameservers"
	_apply_remote_conf  "firewall/redirects"
	_apply_remote_conf  "firewall/rules"
	_apply_remote_conf  "glorytun/tun"
	_apply_remote_conf  "network/interfaces"
	_apply_remote_conf  "network/routes4"
	_apply_remote_conf  "network/routes6"
}

_run
